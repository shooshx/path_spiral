<html><head>
<script>

var ctx = null

//var READ_FACTOR = 0.5
var READ_FACTOR = 1

var STEP_SIZE = 5 //10
var GAP = 20

// controls how deep interlly to try to reach
//var BEG_DIST = 5 // for 1
var BEG_DIST = 7 // for 2
var INNER_UPTO = 20 * (10/STEP_SIZE) // 40 for 5 step

function start()
{
    ctx = canvas.getContext('2d')

    //var ELEM = the_path
    var ELEM = the_path2
   
    process(ELEM)
}

function draw(dpath) {
    ctx.beginPath()
    ctx.moveTo(dpath[0][0], dpath[0][1])
    for(var i = 1; i < dpath.length; ++i) {
        ctx.lineTo(dpath[i][0], dpath[i][1])
    }
    ctx.stroke()
}
function drawNormals(coords, normals) {
    for(var i = 0; i < coords.length; ++i) {
        ctx.beginPath()
        ctx.moveTo(coords[i][0], coords[i][1])
    
        ctx.lineTo(coords[i][0] + normals[i][0]*20, coords[i][1] + normals[i][1]*20)
        ctx.stroke()
    }
}
function drawPoints(coords,sz)
{
    for(var i = 0; i < coords.length; ++i) {
        ctx.fillRect(coords[i][0]-sz, coords[i][1]-sz, 1+sz*2, 1+sz*2)
    }
}


function vAddInto(a, b) {
    a[0] += b[0]
    a[1] += b[1]
}
function vPrn(a) {
    console.log("["+a[0]+","+a[1]+"]")
}
function vStr(a) {
     return "["+a[0]+","+a[1]+"]"
}
function vMult(a, v) {
    a[0] *= v
    a[1] *= v
}
function vMulted(a, v) {
    return [a[0]*v, a[1]*v]
}
function vSub(a, b) {
    return [a[0]-b[0], a[1]-b[1]]
}
function vAdd(a, b) {
    return [a[0]+b[0], a[1]+b[1]]
}
function vPerp(a) {
    return [a[1],-a[0]]
}
function vNormalize(a) {
    var ilen = 1.0 / Math.sqrt(a[0]*a[0] + a[1]*a[1])
    a[0] *= ilen
    a[1] *= ilen
}
function vEqEps(a,b,eps) {
    return Math.abs(a[0]-b[0]) < eps && Math.abs(a[1]-b[1]) < eps
}
function vDistSqr(a, b) {
    var dx = a[0]-b[0]
    var dy = a[1]-b[1]
    return dx*dx + dy*dy
}
function vDist(a, b) {
    return Math.sqrt(vDistSqr(a,b))
}
function vDot(a, b) {
    return a[0]*b[0] + a[1]*b[1]
}
function vNeg(a) {
    return [-a[0], -a[1]]
}

function readPath(pathElem) 
{
    var d = pathElem.getAttribute('d')
    dElem = d.split(' ')
    var typ = dElem.shift()
    if (typ != 'm') {
        console.log("not supported " + typ)
        return;
    }
    cur = [0,0]
    coords = []
    for(var i = 0; i < dElem.length; ++i) {
        cs = dElem[i].split(',')
        c = [parseFloat(cs[0]), parseFloat(cs[1])]
        vAddInto(cur, c)
        var curx = cur.slice()
        
        vMult(curx, READ_FACTOR)
        vAddInto(curx, [350,100])
        coords.push(curx) // copy it
    }
    if (vEqEps(coords[0], coords[coords.length-1], 0.01))
        coords.pop()
    return coords
}

function calcNormals(coords)
{
    var normals = []
    for(var i = 0; i < coords.length; ++i) {
        var prev = coords[(i-1+coords.length) % coords.length] // cyclic
        if (i == 0)
            prev = coords[(i-2+coords.length) % coords.length] // first point is repeated as last point so need to skip it
        var cur = coords[i];
        var next = coords[(i+1) % coords.length]
        if (i == coords.length - 1)
            next = coords[1]
        
        var dirFromPrev = vSub(cur, prev)
        var dirFromNext = vSub(cur, next)

        var p1 = vPerp(dirFromPrev)
        var p2 = vNeg(vPerp(dirFromNext))
                
        vNormalize(p1)
        vNormalize(p2)

        vAddInto(p1, p2)
        vNormalize(p1)

        normals.push(p1)
    }
    return normals
}

function calcNormalsConcentric(coords)
{
    var normals = []
    var avg = [0,0]
    
    for(var i = 0; i < coords.length; ++i) {
        vAddInto(avg, coords[i])
    }
    vMult(avg, 1.0/coords.length)
    for(var i = 0; i < coords.length; ++i) {
        var toP = vSub(coords[i], avg)
        vNormalize(toP)
        normals.push(toP)
    }
    return normals
}


function openEnd(coords, normals)
{
    var scalar = 0
    for(var i = coords.length - 20; i < coords.length; ++i) 
    {
        var d = normals[i].slice()
        vMult(d, scalar*GAP)
        vAddInto(coords[i], d)
        scalar += 0.05
    }
}

function leftPad(s, len, ch) {
    while (s.length < len)
        s = ch + s
    return s
}

// upto allows to not render the last one which will interfere with the trace
function renderLineInner(coords, upto, upfrom, p) 
{
    //ctx.fillRect(0,0,canvas.width, canvas.height)
    ctx.lineWidth = GAP*2
    ctx.lineJoin = 'round'
    ctx.lineCap = 'butt' //'square'

    var c1 = 0, c2 = 0, c3 = 0
    ctx.strokeStyle = "#ff0000"
    ctx.beginPath()
    ctx.moveTo(coords[upto][0], coords[upto][1])
    for(var i = 1+upto; i < coords.length-upfrom; ++i) {
        ctx.lineTo(coords[i][0], coords[i][1])
        ++c1;
    }
    ctx.stroke()

    // start of the line add blue to detect we're reaching the center of the shape
    ctx.strokeStyle = "#ff00ff"
    ctx.beginPath()
    ctx.moveTo(coords[upto][0], coords[upto][1])
    for(var i = 1+upto; i < BEG_DIST+upto; ++i) {
        ctx.lineTo(coords[i][0], coords[i][1])
        ++c2
    }
    ctx.stroke()
    
    //console.log("COUNTS " + c1 + " " + c2 + " " + c3)
       
    var winX, winY, winH, winW
    if (p == null) {
        winX = winY = 0
        winW = canvas.width
        winH = canvas.height
    }
    else {
        winX = p[0] - STEP_SIZE - 5
        winY = p[1] - STEP_SIZE - 5
        winH = winW = STEP_SIZE*2+10        
    }
    
    var idt8 = ctx.getImageData(winX, winY, winW, winH).data;
    var idt = new Uint32Array(idt8.buffer)
    return {d:idt, w:canvas.width, h:canvas.height, winX:winX, winY:winY, winH:winH, winW:winW}

}

function renderLineOuter(coords, upto, upfrom, p) 
{
    //ctx.fillRect(0,0,canvas.width, canvas.height)
    ctx.lineWidth = GAP*2
    ctx.lineJoin = 'round'
    ctx.lineCap = 'butt' //'square'

    var c1 = 0, c2 = 0, c3 = 0
    ctx.strokeStyle = "#ff0000"
    ctx.beginPath()
    ctx.moveTo(coords[upto][0], coords[upto][1])
    for(var i = 1+upto; i < coords.length-upfrom; ++i) {
        ctx.lineTo(coords[i][0], coords[i][1])
        ++c1;
    }
    ctx.stroke()

    ctx.strokeStyle = "#ff00aa"
    ctx.beginPath()
    ctx.moveTo(coords[coords.length-upfrom-5-2][0], coords[coords.length-upfrom-5-2][1])
    for(var i = coords.length-upfrom-5-1; i < coords.length-upfrom; ++i) {
        ctx.lineTo(coords[i][0], coords[i][1])
        ++c3
    }
    ctx.stroke()

    //console.log("COUNTS " + c1 + " " + c2 + " " + c3)
    
    
    var winX, winY, winH, winW
    if (p == null) {
        winX = winY = 0
        winW = canvas.width
        winH = canvas.height
    }
    else {
        winX = p[0] - STEP_SIZE - 5
        winY = p[1] - STEP_SIZE - 5
        winH = winW = STEP_SIZE*2+10        
    }
    
    var idt8 = ctx.getImageData(winX, winY, winW, winH).data;
    var idt = new Uint32Array(idt8.buffer)
    return {d:idt, w:canvas.width, h:canvas.height, winX:winX, winY:winY, winH:winH, winW:winW}

}



// 2 1 0
// 4   3
// 7 6 5 

var cell2Move = [ [1, -1], [0, -1], [-1, -1], [1, 0], [-1, 0], [1, 1], [0, 1], [-1, 1], [0, 0]] // 0,0 is not really supported anywhere else

var opposite = [ 7, 6, 5, 4, 3, 2, 1, 0 ];

var considerOrderNorm = [
	[ 1, 2, 4, 7, 6, 5, 3, 0 ],
	[ 2, 4, 7, 6, 5, 3, 0, 1 ],
	[ 4, 7, 6, 5, 3, 0, 1, 2 ],
	[ 0, 1, 2, 4, 7, 6, 5, 3 ],
	[ 7, 6, 5, 3, 0, 1, 2, 4 ],
	[ 3, 0, 1, 2, 4, 7, 6, 5 ],
	[ 5, 3, 0, 1, 2, 4, 7, 6 ],
	[ 6, 5, 3, 0, 1, 2, 4, 7 ] ];

function getPathCenter(coords) {
    var c = [0,0]
    for(var i = 0; i < coords.length; ++i) {
        vAddInto(c, coords[i])
    }
    vMult(c, 1.0/coords.length)
    return [Math.round(c[0]), Math.round(c[1])]
}    

function pMove(p, mi) {
    console.assert(mi >= 0 && mi < 8)
    var m = cell2Move[mi]
    vAddInto(p, m)
}
function iRealCoord(img, p) {
    var r = [p[0]-img.winX, p[1]-img.winY]
    if (r[0] >= 0 && r[0] < img.winW && r[1] >= 0 && r[1] < img.winH)
        return r
    //console.assert(r[0] >= 0 && r[0] < img.winW && r[1] >= 0 && r[1] < img.winH)
    return null
}
function iGet(imgdt, ap) {
    var p = iRealCoord(imgdt, ap)
    if (p == null)
        return 0xffffffff
    return imgdt.d[p[0] + p[1]*imgdt.winW]
}
function iMoveGet(imgdt, p, mi) {
    console.assert(mi >= 0 && mi < 8)
    var m = cell2Move[mi]
    return iGet(imgdt, [p[0]+m[0], p[1]+m[1]])
}
function iPut(imgdt, ap, v) {
    var p = iRealCoord(imgdt, ap)
    if (p == null)
        return
    imgdt.d[p[0] + p[1]*imgdt.winW] = v
}
function pMoveEq(p, mi, t) {
    var m = cell2Move[mi]
    return (p[0]+m[0]==t[0] && p[1]+m[1]==t[1])
}
function bEq(a, b) {
    // this is a workaround due to signes of numbers. make them both signed (assumes a is already a result of bitwise op)
    return (a == (b | 0))
}

function goToRightEdge(start, img)
{
    var p = start.slice()
    while(true) {
        var n = p.slice()
        pMove(n, 3)
        var v = iGet(img, n)
        if (v != 0)
            break;
        p = n    
    }
    return p
} 


// ||
// atBeg - true if we're doing the internal, false if the external
function traceInner(trStart, img, cameFrom, coords)
{
    var curPntCount = 0; // points added before making a line
    var lastCoord = coords[0] 
    
    var p = trStart.slice()
    
    var iter = 0
    var reachedStart = false
    var oc = 0;

    var upto = INNER_UPTO // how far back to leave the paint trail so it wont interfere with the trace
    var upfrom = 0
    var didSeeBlue = false // used to lower upto when reaching the center
    while(true) 
    {
        ++iter
        //console.log("PP " + iter + " " + vStr(p))
        if (iter == 14000 )
            break
       // if (iter == 3391)
       //     console.log("PROB")

        if ((curPntCount % STEP_SIZE) == 0) 
        { // want to add the first one
            var pc = p.slice()
            coords.splice(0,0,pc)
            // the order we send the color is 0xRRGGBB
            img = renderLineInner(coords, upto, upfrom, p)
            lastCoord = pc
        }
        ++curPntCount;
        iPut(img, p, 0x0000ffff)
        
        var order = considerOrderNorm[cameFrom]
        var foundmi = -1
        for(oi = 0; oi < 8; ++oi) {
            var mi = order[oi];
            var v = iMoveGet(img, p, mi) // the order we get the color is 0xAABBGGRR 
            if ((v & 0x00ff0000) == 0x00ff0000)
                didSeeBlue = true
            v &= 0xff00ffff // mask the oc
            if (!bEq(v, 0xff0000ff) ) {
                foundmi = mi
                break;
            }
            if (pMoveEq(p, mi, trStart)) {
                reachedStart = true
                break;
            }
        }   
        if (reachedStart) // one of the places we considered is the start pos
            break
        if (foundmi == -1)
            break
        //console.assert(foundmi != -1) // did not find where to go

        if (didSeeBlue) {
            upto = Math.max(1, upto-1)
            console.log("SEE-BLUE " + iter + " lowering " + upto)
            if (upto == BEG_DIST) {
                coords.splice(0,0,p.slice())
                break
            }
            didSeeBlue = false
            img = renderLineInner(coords, upto, upfrom, p)
        }

        pMove(p, foundmi)
        cameFrom = opposite[foundmi]
        
    }
    console.log("round " + iter)

}

function traceOuter(trStart, img, cameFrom, coords)
{
    var curPntCount = 0; // points added before making a line
    var lastCoord = coords[coords.length-1] 
    
    var p = trStart.slice()
    
    var iter = 0
    var reachedStart = false
    var oc = 0;

    var upto = 0 // how far back to leave the paint trail so it wont interfere with the trace
    var upfrom = 20
    
    var img = renderLineOuter(coords, 0, upfrom, null)
    var circStart = coords.length-upfrom-1-6
    while(true) 
    {
        ++iter
        //console.log("PP " + iter + " " + vStr(p))
        if (iter == 85000 )
            break

        if ((curPntCount % STEP_SIZE) == 0) 
        { // want to add the first one
            var pc = p.slice()

            upto = coords.length - 20
            coords.push(pc)

            // the order we send the color is 0xRRGGBB
            lastCoord = pc
        }
        ++curPntCount;
        iPut(img, p, 0x0000ffff)
        
        var order = considerOrderNorm[cameFrom]
        var foundmi = -1
        for(oi = 0; oi < 8; ++oi) {
            var mi = order[oi];
            var v = iMoveGet(img, p, mi) // the order we get the color is 0xAABBGGRR 
            if ((v & 0x00ff0000) == 0x00aa0000) { 
                
                img = renderLineOuter(coords, circStart, upfrom, null)
                console.log(iter + " CIRC")
                circStart = coords.length-upfrom-1-6

            }

            v &= 0xff00ffff // mask the oc
            if (!bEq(v, 0xff0000ff) ) {
                foundmi = mi
                break;
            }
            if (pMoveEq(p, mi, trStart)) {
                reachedStart = true
                break;
            }
        }   
        if (reachedStart) // one of the places we considered is the start pos
            break
        if (foundmi == -1)
            break
        //console.assert(foundmi != -1) // did not find where to go


        pMove(p, foundmi)
        cameFrom = opposite[foundmi]
        
    }
    console.log("round " + iter)

}



// from inside the red
function findEdge(img, from, dir)
{
    var p = from.slice()
    while(true) {
        var n = p.slice()
        vAddInto(n, [0.5*dir[0],0.5*dir[1]]) // go slow to not miss integers
        var r = [Math.round(n[0]), Math.round(n[1])]
        var v = iGet(img, r)
        //console.log("FE " + r + " " + v.toString(16))
        v &= 0xff00ffff
        if (!bEq(v, 0xff0000ff))
            return r; // want the one that is just outside
        p = n    
    }
    return null
}

function findStartCameFrom(img, stp)
{
    for(var i = 0; i < 8; ++i) {
        var v = iMoveGet(img, stp, i)
        v &= 0xff00ffff
        if (bEq(v, 0xff0000ff))
            return i; // want something that is inside
    }
}

function process(pathElem)
{
    coords = readPath(pathElem) // [x,y]
    realNormals = calcNormals(coords) // returns [nx,ny]
    conNormals = calcNormalsConcentric(coords)
    //draw(coords)
    //drawNormals(coords, realNormals)
    //openEnd(coords, conNormals)

    openEnd(coords, conNormals)

    //var stp = coords[0].slice()
    var img = renderLineInner(coords, 0, 0, null, coords.length)
    
    // the point inside, where the inward spiral should start from
    var edgeDir = vNeg(realNormals[coords.length-1])
    var pdir = vSub(coords[coords.length-2], coords[coords.length-1])
    vNormalize(pdir)
    vMult(pdir, 4)
    vAddInto(pdir, coords[coords.length-1])

    var stp = findEdge(img, pdir, edgeDir)
    var cameFrom = findStartCameFrom(img, stp)
    console.log("start " + stp + " " + cameFrom)
    
    // the point at the outside where the outward spiral should start
    var oedgeDir = realNormals[0]
    var opdir = vSub(coords[1], coords[0]) // where to start from
    vNormalize(opdir)
    vMult(opdir, 4)
    vAddInto(opdir, coords[0])
    
    traceInner(stp, img, cameFrom, coords) 
    //ctx.fillStyle = "#ffffff"
    //ctx.fillRect(0,0,canvas.width,canvas.height)

    var img = renderLineInner(coords, 0, 0, null, coords.length)    
    var etp = findEdge(img, opdir, oedgeDir)
    var ocameFrom = findStartCameFrom(img, etp)
   
    traceOuter(etp, img, ocameFrom, coords) 
    
    ctx.fillStyle = "#6600ff"
   // drawPoints(coords,1)
    //drawPoints(trp,1)
    //drawPoints([etp, opdir],2)
    ctx.fillStyle = "#00FF00"
    //drawPoints([stp],2)
    ctx.fillStyle = '#ffffff'
  //  ctx.fillRect(0,0,canvas.width,canvas.height)
  
    ctx.strokeStyle = "#000000"
    ctx.lineWidth = 1

    draw(coords)
}


</script>
<style>
#canvas {
    border: 1px solid red;
}

</style>
</head>
<body onload="start()">
<canvas id="canvas" width="1200" height="700"></canvas>


<svg
   xmlns:svg="http://www.w3.org/2000/svg"
   xmlns="http://www.w3.org/2000/svg"
   width="210mm"
   height="297mm"
   viewBox="0 0 744.09448819 1052.3622047"
   version="1.1"

  <g
     id="layer1">
    <path
       id="the_path"
       d="m 657.14287,732.36219 -42.93428,44.16165 -15.94699,13.17146 -13.209,8.13118 -11.17757,3.76538 -9.85272,0.0741 -9.23445,-2.94276 -9.32274,-5.28511 -21.73668,-14.89936 -30.56875,-16.17499 -20.36284,-6.87967 -24.69058,-5.17513 -29.72489,-2.79612 -35.46578,0.25737 -35.30063,3.42838 -29.27359,5.86896 -24.01937,7.71211 -19.53797,8.95783 -28.72301,19.26311 -20.07125,17.07685 -8.72326,6.22501 -8.87877,3.88615 -9.8071,0.94988 -11.50826,-2.58384 -13.98224,-6.71497 -17.22902,-11.44353 -47.2897,-39.46249 -44.161652,-42.93427 -13.171453,-15.947 -8.131179,-13.20899 -3.765386,-11.17757 -0.07407,-9.85273 2.942758,-9.23444 5.285111,-9.32274 14.899354,-21.73668 16.174996,-30.56875 6.879662,-20.36283 5.175132,-24.69058 2.79612,-29.72489 -0.257372,-35.46579 -3.428379,-35.30062 -5.868957,-29.27359 -7.712109,-24.01937 -8.95783,-19.53797 -19.263109,-28.72302 -17.076851,-20.07125 -6.225006,-8.72326 -3.886156,-8.87877 -0.949876,-9.8071 2.583833,-11.50826 6.71497,-13.98224 11.443535,-17.22902 39.462485,-47.2897 42.934273,-44.16165 15.947,-13.17146 13.20899,-8.13117 11.17757,-3.76539 9.85272,-0.0741 9.23445,2.94275 9.32274,5.28511 21.73668,14.89936 30.56875,16.17499 20.36283,6.87967 24.69058,5.17513 29.7249,2.79612 35.46578,-0.25738 35.30063,-3.42837 29.27358,-5.86896 24.01938,-7.71211 19.53797,-8.95783 28.72301,-19.26311 20.07125,-17.07685 8.72326,-6.225 8.87877,-3.88616 9.80711,-0.94987 11.50826,2.58383 13.98223,6.71497 17.22903,11.44354 47.2897,39.46248 44.16165,42.93427 13.17145,15.947 8.13118,13.20899 3.76538,11.17757 0.0741,9.85273 -2.94276,9.23444 -5.28511,9.32274 -14.89935,21.73668 -16.175,30.56875 -6.87966,20.36284 -5.17513,24.69058 -2.79612,29.72489 0.25737,35.46578 3.42838,35.30063 5.86895,29.27359 7.71211,24.01937 8.95783,19.53797 19.26311,28.72301 17.07685,20.07125 6.225,8.72326 3.88616,8.87877 0.94988,9.8071 -2.58384,11.50826 -6.71497,13.98224 -11.44353,17.22902 -39.46248,47.2897 0,0"
       style="opacity:1;fill:none;fill-opacity:1;stroke:#ec0000;stroke-width:14.91600037;stroke-linecap:round;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:0.7254902"
       inkscape:connector-curvature="0" />
  </g>
</svg>

<svg
   xmlns:dc="http://purl.org/dc/elements/1.1/"
   xmlns:cc="http://creativecommons.org/ns#"
   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
   xmlns:svg="http://www.w3.org/2000/svg"
   xmlns="http://www.w3.org/2000/svg"
   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
   width="343pt"
   height="340pt"
   id="svg3058"
   version="1.1"
   inkscape:version="0.91 r13725"
   sodipodi:docname="test3.svg">
  <defs
     id="defs3060" />
  <sodipodi:namedview
     pagecolor="#ffffff"
     bordercolor="#666666"
     borderopacity="1.0"
     inkscape:pageopacity="0.0"
     inkscape:pageshadow="2"
     inkscape:zoom="0.8"
     inkscape:cx="2.5"
     inkscape:cy="210"
     inkscape:document-units="pt"
     inkscape:current-layer="layer1"
     id="namedview3062"
     showgrid="false"
     inkscape:window-width="1440"
     inkscape:window-height="848"
     inkscape:window-x="-8"
     inkscape:window-y="-8"
     inkscape:window-maximized="1" />
  <metadata
     id="metadata3064">
    <rdf:RDF>
      <cc:Work
         rdf:about="">
        <dc:format>image/svg+xml</dc:format>
        <dc:type
           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
        <dc:title></dc:title>
      </cc:Work>
    </rdf:RDF>
  </metadata>
  <g
     inkscape:label="Layer 1"
     inkscape:groupmode="layer"
     id="layer1">
    <path
       style="fill:none;fill-opacity:1;stroke:#000000;stroke-opacity:1"
       inkscape:connector-curvature="0"
       d="m 19.315246,205 1.408432,-11.73537 4.064718,-11.20631 6.480132,-10.35802 8.654678,-9.19055 10.588353,-7.70385 12.28116,-5.89796 13.733096,-3.77287 14.944162,-1.32855 3.163196,0.0633 3.161945,0.18494 3.153192,0.2992 3.13695,0.40609 3.11319,0.50558 3.08194,0.59769 3.04319,0.68242 2.99694,0.75976 -5.44303,-6.12794 -5.01773,-6.51194 -4.49981,-6.88668 -3.889315,-7.25213 -3.18621,-7.6083 -2.39051,-7.9552 -1.502211,-8.292824 -0.521314,-8.621166 1.033674,-12.454104 2.996733,-11.481666 4.803358,-10.297139 6.453545,-8.900525 7.94731,-7.291821 9.28464,-5.471029 10.46552,-3.438149 11.48998,-1.19318 11.15376,1.077697 11.03342,3.171637 10.66386,5.173394 10.04511,7.08297 9.17714,8.900363 8.05997,10.625574 6.69359,12.258602 5.078,13.799449 5.078,-13.799449 6.69359,-12.258602 8.05997,-10.625574 9.17714,-8.900363 10.04511,-7.08297 10.66386,-5.173394 11.03342,-3.171637 11.15376,-1.077697 11.48998,1.19318 10.46552,3.438149 9.28464,5.471029 7.9473,7.291821 6.45355,8.900525 4.80336,10.297139 2.99674,11.481666 1.03367,12.454104 -0.52131,8.621166 -1.50222,8.292824 -2.3905,7.9552 -3.18621,7.6083 -3.88932,7.25213 -4.49981,6.88668 -5.01772,6.51194 -5.44303,6.12794 2.99694,-0.75976 3.04319,-0.68242 3.08194,-0.59769 3.11319,-0.50558 3.13694,-0.40609 3.1532,-0.2992 3.16195,-0.18494 3.1632,-0.0633 14.94416,1.32855 13.73309,3.77287 12.28115,5.89796 10.58835,7.70385 8.65468,9.19055 6.48013,10.35802 4.06472,11.20631 1.40843,11.73537 -1.40843,11.73537 -4.06472,11.20631 -6.48013,10.35802 -8.65468,9.19055 -10.58835,7.70385 -12.28115,5.89796 -13.73309,3.77287 -14.94416,1.32855 -3.1632,-0.0633 -3.16195,-0.18494 -3.1532,-0.2992 -3.13694,-0.40609 -3.11319,-0.50558 -3.08194,-0.59769 -3.04319,-0.68242 -2.99694,-0.75976 5.44303,6.12794 5.01772,6.51194 4.49981,6.88668 3.88932,7.25213 3.18621,7.6083 2.3905,7.9552 1.50222,8.29282 0.52131,8.62117 -1.03367,12.45411 -2.99674,11.48166 -4.80336,10.29714 -6.45355,8.90052 -7.9473,7.29182 -9.28464,5.47103 -10.46552,3.43815 -11.48998,1.19318 -11.15377,-1.0777 -11.03344,-3.17163 -10.66389,-5.1734 -10.04513,-7.08297 -9.17715,-8.90036 -8.05997,-10.62557 -6.69356,-12.2586 -5.07794,-13.79945 -5.078,13.79945 -6.69359,12.2586 -8.05997,10.62557 -9.17714,8.90036 -10.04511,7.08297 -10.66386,5.1734 -11.03342,3.17163 -11.15376,1.0777 -11.48998,-1.19318 -10.46552,-3.43815 -9.28464,-5.47103 -7.94731,-7.29182 -6.453545,-8.90052 -4.803358,-10.29714 -2.996733,-11.48166 -1.033674,-12.45411 0.521314,-8.62117 1.502211,-8.29282 2.39051,-7.9552 3.18621,-7.6083 3.889315,-7.25213 4.49981,-6.88668 5.01773,-6.51194 5.44303,-6.12794 -2.99694,0.75976 -3.04319,0.68242 -3.08194,0.59769 -3.11319,0.50558 -3.13695,0.40609 -3.153192,0.2992 -3.161945,0.18494 -3.163196,0.0633 -14.944162,-1.32855 -13.733096,-3.77287 -12.28116,-5.89796 -10.588353,-7.70385 -8.654678,-9.19055 -6.480132,-10.35802 -4.064718,-11.20631"
       id="the_path2"
       sodipodi:nodetypes="ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc" />
  </g>
</svg>


</body>
</html>